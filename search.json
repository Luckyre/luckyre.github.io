[{"categories":["projectManage","Notes"],"content":"项目管理者 角色转化项目管理者 误区 1：凡事恨不得事必躬亲 成功施加影响的三个层次，分别是让人知道要做（Awareness）、有动力做（Desire）和有能力做（Ability） 单方面的工作交代和告知、停留在浅层次的信息传达上，只是让人知道要做，但并不足以让人产生动力，去促进有效的行动。 讲清楚为什么要做、为什么要现在做、获取理解及认可、激发团队的动力是项目经理成功授权工作的关键 误区 2：追在别人屁股后面做监工 要明确目标、建立机制，并且让这个机制运转起来，最终在项目组形成一种良性的秩序 要始终依靠流程和规则来约束大家的行为 误区 3：拿着锤子，看哪里都是钉子 从项目和团队当前的真实痛点出发 ","description":"","title":"项目管理学习笔记-角色转化误区","uri":"/tech/projectnotes/%E8%A7%92%E8%89%B2%E8%BD%AC%E5%8C%96%E8%AF%AF%E5%8C%BA/"},{"categories":["projectManage","Notes"],"content":"项目中的四类干系人 高利益-高权力、 高利益-低权力、 低利益-高权力、 低利益-低权力 高利益-高权力代表：项目发起人 针对发起人做一轮全面而深入的了解。是非常有必要的 同时，为了管理好之后的沟通，你还需要约定好你们之间的沟通频率和方式，以便在项目进行的过程中做好实时同步 低利益-高权力代表：职能经理 强烈的态度背后，一定反馈了干系人对现状的某种认知 只有真正地理解了对方的逻辑，才有可能进一步对其施加影响 高利益-低权力代表：项目组成员 管理这类干系人的核心，就是做到项目事项的随时告知，及时通报项目的进度和困难 低利益-低权力代表：外围支持人员 ","description":"","title":"项目管理学习笔记-启动：识别项目中的四类干系人","uri":"/tech/projectnotes/%E5%90%AF%E5%8A%A8%E8%AF%86%E5%88%AB%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%B9%B2%E7%B3%BB%E4%BA%BA/"},{"categories":["projectManage","Notes"],"content":"什么是项目管理？ 项目管理就是变理想为现实，化抽象为具体的一门科学和艺术 项目管理的十大知识领域 干系人管理：如何管理干系人？ 范围管理：做什么？——确保围绕预期目标来设计相应的活动方案 进度管理：花多长时间？——要规划好阶段性步骤，同时明确每个里程碑的目标成果和时间安排 成本管理：花多大代价？ 质量管理：达到什么要求？ 资源管理：有多少还要买？ 沟通管理：如何管理沟通？ 风险管理：如何应对风险？—— 需要提前做好系统性的风险识别，分等级制定应对策略 整合管理：如何实现整体最优？ 项目管理的五大过程组 1、启动过程组（千里之行始于足下） 启动过程组意味着正式开始一个项目，或者是开始一个项目中的新阶段，包括识别干系人和制定项目章程两个子过程 正式宣告一个新的项目或新阶段的开始，公开确认项目章程，包括明晰各方干系人的期望和诉求，设定愿景目标和重要里程碑，确定责任分工和沟通机制等 2、规划过程组（运筹帷幄，决胜千里） 规划就是把愿景目标转化为可落地的行动方案和工作路线 3、执行过程组（言出必行，行之必果） 4、监控过程组（审时度势，沉着应变） 5、收尾过程组（慎终如始，则无败事） 不管项目成功与否，“趁热”复盘都是极为重要的一步 互联网项目管理的职责定位 提效能就是去关注和消灭团队中的低价值工作所引发的效能痛点、 促协作则是着眼于使用各种项目管理方法和工具，让高价值工作者可以更好的合作 保目标，助决策是要打通从战略到执行的闭环，提效能、促协作则是打通上下游协作的闭环 ","description":"","title":"项目管理学习笔记-十大领域五大过程组","uri":"/tech/projectnotes/%E5%8D%81%E5%A4%A7%E9%A2%86%E5%9F%9F%E4%BA%94%E5%A4%A7%E8%BF%87%E7%A8%8B%E7%BB%84/"},{"categories":["uniapp"],"content":"uniapp uni-app是一个Vue.js开发所有前端应用的框架，开发者通过开发一套代码，然后打包适配、发布到IOS、Android、Web(响应式)、以及现在各大平台的小程序、快应用等多个平台。\n时间线拉到19年，我记得当时去上海的交大徐汇校区参加了VUECONF，参加技术分享大会看到了Winter、蒋豪群、尤雨溪等大佬的分享。\n当时也第一次听到了DCloud前端架构师以“vue开发小程序之性能优化”的主题来介绍了uni-app、当时基于微信平台，很多公司也有基于微信开源特有的框架、如wepy、mpvue、Megalo、mpx等。所以眼球上没有很大去注意。当时都放在了尤大大身上、去追签名照😄\nuniapp 使用体验 uniapp的开发工具也是官方推荐的HBuilder、工具内部也继承了相关基本构建、打包多平台机制，其他需要特殊配置的插件也有点相似与VSCode一样，安装相应插件包\n语法层面很多都是vue的语法，但是生命周期与微信开发的生命周期类似\nuniapp 可以通过 uniCloud整合后台业务\nuniClound 目前是可以在阿里云与腾讯云为开发者基于serverless模式和JS编程的云开发平台，简单来说就是前端可以使用JS开发后端的业务，而不用去学习后台一些语言\nuniClound 1、通过注册账号，选择相应的服务商、连接对应的uniClound 数据库\n2、通过创建服务空间，关联相应的项目。然后就可以通过在uniClound云数据库中建立数据表、通过建立本地建立云函数api去获取云数据表,如下的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 获取数据库的引用 'use strict'; const db = uniCloud.database() const $ = db.command.aggregate exports.main = async (event, context) =\u003e { const { user_id } = event // author_likes_ids let userinfo = await db.collection('user').doc(user_id).get() //获取user表数据 userinfo = userinfo.data[0] let lists = await db.collection('user') .aggregate() .addFields({ is_like: $.in(['$id', userinfo.author_likes_ids]) }) .match({ is_like: true }) .end() //返回数据给客户端 return { code: 200, msg: '数据获取成功', data: lists.data } }; // 前台通过调用相应的云函数名关联 uniCloud.callFunction({ name: url, //封装的云函数名 data //请求参数 }) uni组件 uni组件存在基础组件与自定义扩展封装组件\n1、基础组件内部有一些官方定义的view、scroll-view、progress、navigator等原生组件、直接使用 1 2 3 4 5 \u003cscroll-view class=\"list-scroll\" scroll-y @scrolltolower=\"loadmore\"\u003e \u003cview\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/view\u003e \u003c/scroll-view\u003e 2、外部组件通过插件市场 下载安装，即会在uni_modules目录显示，可直接在相关业务场景使用,无需import环节，开箱即用的感觉。对比与传统的安装、引用、注册，三个步骤后才能使用组件流程确实精简。\n3、组件的通用性，难免存在二次封装，在uni中可直接在components目录下创建或者全局创建、挂载在Vue.component上\n1 2 3 4 │─components 符合vue组件规范的uni-app组件目录 │ └─componentA 符合‘components/组件名称/组件名称.vue’目录结构，easycom方式可直接使用组件 │ └─componentA.vue 可复用的componentA组件 │ └─component-a.vue 可复用的component-a组件 ","description":"","title":"uniapp 初识","uri":"/tech/uniapp-first/"},{"categories":["博客搭建","hugo"],"content":"前言 对于博客搭建，hexo怕是大家都耳熟能详，但是hugo是比较新的一种搭建方式，Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n两者的文章书写方式都是MarkDown的语法，对于迁移有很大的帮助。hugo的快速和MemE让我眼前一亮，以下是我通过hexo迁移hugo历程\nwindows安装 针对于不同的操作系统，安装过程会有所不同，我以windows为例，通过hugo releases地址 选择相关系统的压缩包\n提示:\n1、下载带有extended的扩展版包\n2、在windows的环境变量Path中配置hugo路径\nHugo的使用 先查看hugo版本，然后进行博客站点的创建\n1 2 hugo version hugo new site blog 命令执行之后生成目录结构及与Hexo的目录结构的差异性\n. # 说明 Hexo ├── archetypes/ # 文章模板 scaffolds/ ├── assets/ # Hugo 管道 ├── config.toml # 配置文件 _config.yml ├── content/ # 文章目录 source/_posts/ ├── data/ # Hugo 数据文件 source/_data/ ├── layouts/ # 布局模板 ├── public/ # 生成的静态文件 public/ ├── resources/ # Hugo 缓存 ├── static/ # 网站的静态文件 source/ └── themes/ # 主题目录 themes/ 安装MemE主题 进入blog站点博客目录,进行主题的安装，例如我选择的MemE主题\n1 2 3 cd blog git init git submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme hugo的blog开始之路 1️、替换 config.toml\n对于简体中文用户，可以通过一下命令替换 config.toml 文件，替换成简体中文版本\n1 rm config.toml \u0026\u0026 cp themes/meme/config-examples/zh-cn/config.toml config.toml 2️、 新建文章\n1 2 hugo new \"posts/hello-world.md\" --buildFuture # buildFuture 解决发布日期前无效生成文章问题 hugo new \"about/_index.md\" # 指定默认文件 在content目录会生成相对应的文件，例如posts/hello-world.md文件，about/_index.md文件，_index.md文件是主页，可以直接在浏览器打开\n在hexo迁移hugo中可以把原来hexo的文件source目录下的文章cp过来\n3、起本地服务\n1 hugo server -D build很快，出现 http://localhost:1313/，可以直接打开浏览器访问，随意更新md文章，博客站点内容会自动更新，整挺好😄\n定制 相关配置可在config.toml文件中进行配置\n你想要自定义样式，推荐在assets目录下创建assets/scss/custom/_custom.scss 文件,不修改theme文件下的样式文件(当时使用hexo就是在theme修改☹️)，以防止覆盖theme目录下的样式文件(别留坑)\n部署🚀 对于部署我们一般只要用到public构建出来的文件目录、然后部署在服务器上，这样可以避免大量的文件上传，提高部署的效率。我使用最简单Github Pages服务搭建\n手动部署 1、在Github上创建一个Repository,命名为 githubName.github.io(githubName替换为你的github用户名 )\n2、执行以下命令关联Github Pages Repository\n1 2 3 4 5 6 cd public git init git remote add origin https://github.com//githubName.githubName.io.git git add -A git commit -m \"first commit\" git push -u origin master 注意: 这种public关联后，整个项目blog想关联其他的github Repository做备份时，需要重复关联git remote add origin 操作，麻烦😢\n自动集成部署（推荐） 使用Github Pages来部署个人网站,通过Github Actions生成站点部署，如下图所示 建立Repositories 1、建立一个Repositories关联 blog项目（公共库或者私有库都行）放置hugo 搭建的blog源码\n2、然后再建一个username/username.gihub.io.git属性为公有(public)库,用来放置打包public目录的文件并设置Github Pages服务.\n设置Deploy keys与Secrets 1、首先，生成新的SSH(新的SSH可以换名称)\n# 修改 username 为你自己的 GitHub 用户名 ssh-keygen -t rsa -b 4096 -C \"username@users.noreply.github.com\" # 注意：这次不要直接回车，以免覆盖之前生成的，比如新生成了deploy_key_repo1私钥,deploy_key_repo1.pub公钥 2、在源码公有(public)库 Settings \u003e Secrets \u003e New secret。填入value为deploy_key_repo1私钥，Name为 DEPLOY_KEY(与 Workflow 配置对应)\n3、前往 GitHub Pages 仓库，Settings \u003e Deploy keys。填入value为deploy_key_repo1.pub公钥,并勾选 Allow write access。\n建立Workflow配置 1、在blog项目目录创建.github/workflows/deploy.yml的文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # .github/workflows/deploy.yml name: build on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: 'Building...' uses: reuixiy/hugo-deploy@v1 env: DEPLOY_REPO: Luckyre/luckyre.github.io DEPLOY_BRANCH: master DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }} # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones commit_message: ${{ github.event.head_commit.message }} 需要调整的就是值如下：\nsteps下的uses配置的是reuixiy作者的hugo-deploy🚀\nDEPLOY_REPO为你的Github Pages的仓库\nDEPLOY_BRANCH 部署分支 DEPLOY_KEY 就是源码库配置的DEPLOY_KEY\n测验流程 1、在本地blog源码库提交一个commit并且push\n2、打开github源码库中查看Actions处的build日志,building报错日志需要细致关注，可以先本地起一下build筛选一些问题，在重复步骤1和2\n3、源码库Actions执行完成后会触发GitHub Pages库的部署更新差不多总流程2分钟不到😃😃\n4、点击你的https://luckyre.github.io/即可查看部署成功的结果\n","description":"","title":"Hexo迁移hugo","uri":"/tech/hexo-hugo/"},{"categories":null,"content":"\nPromise结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 new Promise((resolve, reject)=\u003e{ $.ajax({ url: 'http://www.kaoyaya.com/api/v1/login/isLogin', type: 'post', success(res){ resolve(res); }, error(res){ reject(res) } }) }).then(()=\u003e{ console.log('success', res) },(err)=\u003e{ console.log('error',res) }) 链式Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var PromiseOne = new Promise((resolve, reject)=\u003e{ $.ajax({ url: 'http://www.kaoyaya.com/api/v1/login/isLogin', type: 'post', success(res){ resolve(res); }, error(res){ reject(res) } }) }).then(()=\u003e{ console.log('success') },(err)=\u003e{ console.log('error') }) var PromiseTwo = new Promise((resolve, reject)=\u003e{ $.ajax({ url: 'http://www.kaoyaya.com/api/v1/login/isLogin', type: 'post', success(res){ resolve(res); }, error(res){ reject(res) } }) }).then(()=\u003e{ console.log('success') },(err)=\u003e{ console.log('error') }) PromiseOne.then(()=\u003e{ console.log('PromiseOne success ') return PromiseTwo }).then(()=\u003e{ console.log('PromiseTwo success ') }) ","description":"","title":"promise","uri":"/tech/promise/"},{"categories":["React"],"content":"\nRedux Flow ## ","description":"react生命周期","title":"react-cycle","uri":"/tech/react-cycle/"},{"categories":["React"],"content":"\n初识React react-dom 渲染过程 one 1 2 3 4 5 state 数据 JSX 模板 数据 + 模板结合，生成真实的DOM, 来显示 state数据发生改变 数据 + 模板结合，生成真实的DOM,替换原始的DOM 缺陷 第一次生成了一个完整的DOM片段 第二次生成了一个完整的DOM片段 第二次的DOM替换第一次的DOM,非常耗性能\ntwo 1 2 3 4 5 6 7 state 数据 JSX 模板 数据 + 模板结合，生成真实的DOM, 来显示 state数据发生改变 数据 + 模板结合，生成真实的DOM,并不直接替换原始的DOM 新的DOM和原始的DOM做比对，找差异 用新的DOM（DoucumentFragment）元素替换老的DOM元素 缺陷 性能的提升并不明显\nthree 1 2 3 4 5 6 7 8 state 数据 JSX 模板 数据 + 模板结合 生成虚拟DOM（虚拟DOM就是一个JS对象, 用它来描述真实的DOM） 用虚拟DOM的结构生成真实的DOM, 来显示 state数据发生改变 数据 + 模板结合， 生成新虚拟DOM（极大的提升了性能） 比较原始虚拟DOM和新的虚拟DOM的区别，找出区别中的内容 直接操作DOM,改变元素中的内容 优点 性能提升了 它使得跨端应用得以实现,React Native\n","description":"","title":"react-dom","uri":"/tech/react-dom/"},{"categories":["Javascript"],"content":"处理章节等同级数据节点\n当章节课时这种本属于三层类型数据传入一维数组数据处理时👀 下列为三层同级的一维数组数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const lessonsList = [ {id: '15941', type: 'chapter', title: '第一章 总论'}, {id: '22183', type: 'unit', title: '法律基础'}, {id: '15949', type: 'lesson', title: '第1讲-法的入门'}, {id: '15950', type: 'lesson', title: '第2讲-法律关系'}, {id: '15951', type: 'lesson', title: '第3讲-法律事实'}, {id: '15952', type: 'lesson', title: '第4讲-法的形式与分类'}, {id: '15953', type: 'lesson', title: '第5讲-法律部门与法律体系'}, {id: '22184', type: 'unit', title: '经济纠纷解决途径'}, {id: '15954', type: 'lesson', title: '第1讲-经济纠纷解决途径入门'}, {id: '22218', type: 'lesson', title: '第2讲-仲裁'}, {id: '25602', type: 'lesson', title: '第3讲 民事诉讼'}, {id: '22220', type: 'lesson', title: '第4讲-行政复议'}, {id: '22221', type: 'lesson', title: '第5讲-行政诉讼'}, {id: '22186', type: 'unit', title: '法律责任'}, {id: '22222', type: 'lesson', title: '第1讲-法律责任'}, {id: '15942', type: 'chapter', title: '第二章 会计法律制度'}, {id: '22222', type: 'lesson', title: '第1讲-法律责任'}, ]; 当前台展示需要从一维数组转换为三维数组（章节课时等三层级父子级别关系型数据）(ˇˍˇ) 想～ 封装以下函数进行数据处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 将章节课时同级，改为章-\u003e节、课时 * @param courseLessonLists * @returns {Array} */ function filterLessonLists(courseLessonLists) { const chapterList = lessonListFlatToArry(courseLessonLists, 'chapter'); chapterList.map((val,item) =\u003e{ val.children = lessonListFlatToArry(val,children, 'unit'); // 分离节和课时 }) } function lessonListFlatToArry(list,nodeType){ let indexArray = []; //章或节的索引 let filterTemplateLessonLists = []; list.forEach((valItem,index)=\u003e { if(valItem.type === nodeType) indexArray.push(index); }); indexArray.map((chapterIndex, index, arry)=\u003e{ let obj ={}; if(arry[index +1]) { //章后一个index存在、截取后一个章/节之间 index obj = list[chapterIndex]; obj.isShow = 0; //为了后续控制层级收缩拉升状态 obj.children = list.slice(chapterIndex + 1, arry[index + 1]); }else { // 章后一个index不存在， 截取到最后 obj = list[chapterIndex]; obj.isShow = 0; obj.children = list.slice(0, indexArray[0]); //indexArray[0]为undefined，slice也会截取到末尾 filterTemplateLessonLists[index] = obj; } return filterTemplateLessonLists; }) } ------------------------------------------ 我是分割线------------------------------------------\n1 2 3 4 5 6 7 8 9 数据结构由此 [{}] ===\u003e [{ title:'chapter', children:[{ title:'unit', children: [{ title: 'lesson', children:[]}]} ]}] ","description":"","title":"node-loop","uri":"/tech/node-loop/"},{"categories":["Javascript"],"content":"\njavascript执行:(Promise里的代码为什么比setTimeout先执行) 我们把宿主发起的任务称为宏观任务, 把javascript引擎发起的任务称为微观任务👀 1 2 3 4 5 6 7 var r = new Promise(function(resolve, reject){ console.log(\"a\"); resolve() }); setTimeout(()=\u003econsole.log(\"d\"), 0) r.then(() =\u003e console.log(\"c\")); console.log(\"b\") 以上执行结果可自行尝试运行（abcd😝），d 必定发生在 c 之后，因为 Promise 产生的是javascript引擎内部的微任务，而setTimeout是浏览器的API,它产生宏任务 ,微任务始终先于宏任务 （微观任务不执行完成不会进行宏观任务）\n1 2 3 4 5 6 7 8 9 10 11 12 setTimeout(()=\u003econsole.log(\"d\"), 0) var r1 = new Promise(function(resolve, reject){ resolve() }); r.then(() =\u003e { var begin = Date.now(); while(Date.now() - begin \u003c 1000); console.log(\"c1\") new Promise(function(resolve, reject){ resolve() }).then(() =\u003e console.log(\"c2\")) }); javascript的闭包和执行上下文 javascript ","description":"","title":"javascript小记","uri":"/tech/javascript-execute/"},{"categories":["Hexo"],"content":"\n第一次写博客 记录自己小白的成长模式 😊😊趁着自己学校的特权，买了阿里的云的服务器，备案，hexo的搭建这系列的折腾出了第一个属于自己的博客地址，其中的细节慢慢到来😀，再次感谢大佬们的指点，及博主易 象 辞👍👍\n博客所述 （1）theme https://theme-next.iissnan.com/\n（2）music plugins https://github.com/MoePlayer/APlayer\n（3）首页页面整改style可更改 该主题(next/source/css/_custom)文件下的的custom.styl这个文件style（👀 f12控制台定位元素整改） 🧐可在(next/source/css/main.styl)中查看该style文件暴露的入口\n(4)博客写作所需 $ hexo new [layout] \u003ctitle\u003e 创建新的文章模板 https://hexo.io/zh-cn/docs/writing（具体文档）\nMarkdown语法\nhttps://coding.net/help/doc/project/markdown.html#Markdown\n持续更新中😆 ","description":"","title":"初眼看世界","uri":"/tech/hello-world/"},{"categories":null,"content":"+++ title = \"项目管理学习笔记-规划：排查计划中的延期地雷\" date = \"2023-04-23 22:50:25\" tags = [\"projectManage Notes\"] categories = [\"projectManage\",\"Notes\"] gitinfo = true dropCap = false toc = true +++\n排查计划中的延期地雷 计划是贯穿始终的重要课题，是各个角色协同工作的基准。 利用一切可以利用的资源、尽自己最大的努力达成项目目标 从本质上来讲，计划是用来对焦的！做计划，是个集体对焦的过程 雷区 1：不够具体 好的计划，不仅要给出时间节点，还要给出依据和来源，这样才能更有效地对焦 WBS 工作分解（Work Breakdown Structure）,这是我们做出计划的第一个标准动作 创建 WBS 的过程，也就是把项目工作按阶段可交付成果分解成较小的、更易于管理的组成部分的过程 做计划方式的转变，背后其实是思维方式的根本转变 雷区 2：不够全面 只有任务列表，没有识别关键资源和关键依赖，也就没有考虑研发之外其他环节\n识别依赖并且画出关键路径，就是做计划的第二个标准动作，这一步意味着我们开始从目标的角度对资源进行统筹思考\n通过 Visio 工具明确合作的时间线 雷区 3：不够准确 做计划的第三个标准动作就是定义完成标准，越早的定义完成标准，计划按照期望完成的概率就越大 需求/设计确认、功能完成/提测等时间节点完成标准 雷区 4：没有共识 没有达成共识的计划，是不具备任何效力的 达成共识并且公开透明，就是做计划的第四个标准动作 雷区 5：不够及时 重要的是，每一次进行调整，都要确保项目中的每一个人都知道当前的计划是什么，调整计划需要怎样的决策过程，都需要谁参与决策，而及时调整变更，就是做计划的第五个标准动作 总结 WBS 工作分解，识别依赖及各项环节关键路径，定义完成标准，达成共识并公开透明，及时调整变更 ","description":"","title":"luckyre","uri":"/tech/projectnotes/%E8%A7%84%E5%88%92%E6%8E%92%E6%9F%A5%E8%AE%A1%E5%88%92%E4%B8%AD%E7%9A%84%E5%BB%B6%E6%9C%9F%E5%9C%B0%E9%9B%B7/"}]